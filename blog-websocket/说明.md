/**
     *  Concurrenthashmap 并发安全： WebSocketInfoUtil: 存放连接信息
     *
     *  SimpMessageSendingOperations 消息广播： MessageSendUtil ： 消息推送
     *
     *  File 聊天数据存档： ChatKeepUtil : 聊天数据存档
     *  
     *  WebSocketConsts : 常量类
     *  
     *  api： 1. 在线总人数
     *        2. 发送消息
     *        3. 加入连接
     *        4. 在线人数列表
     *        5. 聊天记录回显
     */
     
     
 public static void main(String[] args) throws Exception {
         DemoF01ReqtM01 demo = new DemoF01ReqtM01();
         Random random = new Random();
         String rootUrl = "C:\\Users\\EDZ\\Desktop\\";
         String dateUrl = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd"));
         String folderUrl = rootUrl + dateUrl + "\\";
         System.out.println(dateUrl);
         File foler =new File(folderUrl);
         if (!foler.exists()){ // 判断当前日期文件夹是否存在
             //foler.mkdir();// 只会建立一级的文件夹
             foler.mkdirs();// 创建路径下所有文件夹
             // file.isDirectory()； //判断是不是一个文件夹
         }
         //
         String fileUrl = folderUrl + "demo" + ".txt";
         File file =new File(fileUrl);
         if (!file.exists()) {
             file.createNewFile();
         }
 
         for (int i = 0; i < 10; i++) {
             demo.setId(UUID.randomUUID().toString());
             demo.setName("name"+ i);
             demo.setAge(random.nextInt(70));
             demo.setBirthDay(new Date());
             demo.setSalary(new BigDecimal(random.nextInt(70)/3));
             writeObj(file, demo);
         }
         List<DemoF01ReqtM01> list = readObj(file);
         for (int i = 0; i < list.size(); i++) {
             System.out.println("读取的数据:"+list.get(i));
         }
     }
 
     public static void writeObj(File file, Object obj) throws IOException {
         boolean isexit = false;
         if (file.exists()) {
             isexit = true;// 序列化文件存在,追加内容
         }
         FileOutputStream fileOutputStream = new FileOutputStream(file,true);
         // 每次new的时候都会写入一个StreamHeader,所以要把屁股后面的StreamHeader去掉
         ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
         long pos = 0;// 可以说是文件的长度
         if (isexit) {
             // getChannel()返回此通道的文件位置，这是一个非负整数，它计算从文件的开始到当前位置之间的字节数
             pos = fileOutputStream.getChannel().position()-4;// TODO 第一次不要减，之后的都要减4 StreamHeader有4个字节所以减去
             // 将此通道的文件截取为给定大小
             fileOutputStream.getChannel().truncate(pos);
             System.out.println("追加成功~");
         }
         objectOutputStream.writeObject(obj);
         // 关闭流
         objectOutputStream.close();
         fileOutputStream.close();
     }
 
     public static List<DemoF01ReqtM01> readObj(File file){
         FileInputStream fileInputStream = null;
         ObjectInputStream objectInputStream = null;
         List<DemoF01ReqtM01> list = new ArrayList<DemoF01ReqtM01>();
         try {
             fileInputStream = new FileInputStream(file);
             objectInputStream = new ObjectInputStream(fileInputStream);
             while (fileInputStream.available() > 0) {
                 list.add((DemoF01ReqtM01) objectInputStream.readObject());
             }
             System.out.println("读取~");
             for (int i = 0; i < list.size(); i++) {
                 System.out.println(list.get(i));
             }
 
         } catch (FileNotFoundException e) {
             // TODO Auto-generated catch block
             e.printStackTrace();
         } catch (IOException e) {
             // TODO Auto-generated catch block
             e.printStackTrace();
         } catch (ClassNotFoundException e) {
             // TODO Auto-generated catch block
             e.printStackTrace();
         }
         return list;
     }